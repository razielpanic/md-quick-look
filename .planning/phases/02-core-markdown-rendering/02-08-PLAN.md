---
phase: 02-core-markdown-rendering
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - md-quick-look/MDQuickLook/MarkdownLayoutManager.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Code block backgrounds render as continuous filled rectangles without gaps between lines"
    - "Blockquote left border renders as continuous vertical bar without gaps between lines"
  artifacts:
    - path: "md-quick-look/MDQuickLook/MarkdownLayoutManager.swift"
      provides: "Line-coalescing background drawing"
      contains: "drawBackground"
  key_links:
    - from: "MarkdownLayoutManager"
      to: "NSLayoutManager"
      via: "drawBackground override with coalesced rects"
      pattern: "boundingRect"
---

<objective>
Fix LayoutManager background gaps (Gaps #12 and #13)

UAT re-test found: Code block backgrounds have "gaps in background" and blockquote borders have "gaps in left bar, extra black line". The custom drawing creates separate rectangles per line instead of continuous backgrounds.

Root cause: `boundingRect(forGlyphRange:)` returns separate bounding boxes per line. When drawing, each line gets its own rectangle with sub-pixel gaps between them.

Purpose: Fix visual rendering quality for code blocks and blockquotes
Output: Smooth, continuous backgrounds and borders without gaps
</objective>

<execution_context>
@/Users/razielpanic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/razielpanic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-core-markdown-rendering/02-VERIFICATION.md
@md-quick-look/MDQuickLook/MarkdownLayoutManager.swift
@samples/comprehensive.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix code block and blockquote background/border gaps</name>
  <files>md-quick-look/MDQuickLook/MarkdownLayoutManager.swift</files>
  <action>
The current implementation uses `boundingRect(forGlyphRange:)` which returns per-line rectangles. This causes gaps between lines when drawing backgrounds.

Fix approach: Enumerate lines within the marked range and draw a single coalesced rectangle that spans all lines.

Replace the current enumeration pattern with line-by-line enumeration that tracks minY and maxY:

```swift
textStorage.enumerateAttribute(.codeBlockMarker,
                              in: charRange,
                              options: []) { value, range, _ in
    guard value != nil else { return }

    let glyphRange = self.glyphRange(forCharacterRange: range, actualCharacterRange: nil)

    // Track the union of all line rects
    var unionRect = NSRect.null

    // Enumerate each line fragment in this range
    self.enumerateLineFragments(forGlyphRange: glyphRange) { lineRect, usedRect, container, lineGlyphRange, stop in
        if unionRect.isNull {
            unionRect = lineRect
        } else {
            unionRect = unionRect.union(lineRect)
        }
    }

    guard !unionRect.isNull else { return }

    // Draw single unified background
    let bgRect = NSRect(x: origin.x + 8,
                       y: origin.y + unionRect.minY,
                       width: textContainer.containerSize.width - 16,
                       height: unionRect.height)

    NSColor.secondarySystemFill.setFill()
    bgRect.fill()
}
```

Apply the same fix to blockquote borders:

```swift
textStorage.enumerateAttribute(.blockquoteMarker,
                              in: charRange,
                              options: []) { value, range, _ in
    guard value != nil else { return }

    let glyphRange = self.glyphRange(forCharacterRange: range, actualCharacterRange: nil)

    var unionRect = NSRect.null

    self.enumerateLineFragments(forGlyphRange: glyphRange) { lineRect, usedRect, container, lineGlyphRange, stop in
        if unionRect.isNull {
            unionRect = lineRect
        } else {
            unionRect = unionRect.union(lineRect)
        }
    }

    guard !unionRect.isNull else { return }

    // Draw continuous vertical bar
    let barWidth: CGFloat = 4
    let barX = origin.x + 4
    let barRect = NSRect(x: barX,
                        y: origin.y + unionRect.minY,
                        width: barWidth,
                        height: unionRect.height)

    NSColor.systemBlue.withAlphaComponent(0.4).setFill()
    barRect.fill()
}
```

The key change: `enumerateLineFragments` provides each line's rect, and we union them together before drawing a single rectangle that covers all lines without gaps.

Also remove any stray drawing code that might cause the "extra black line" mentioned in Gap #13.
  </action>
  <verify>Build with `make build`. Run `qlmanage -p samples/comprehensive.md`. Verify: 1) Code block has smooth continuous background without line gaps, 2) Blockquote has continuous blue border bar without gaps, 3) No stray black lines.</verify>
  <done>Code blocks and blockquotes render with continuous backgrounds/borders, no gaps between lines</done>
</task>

</tasks>

<verification>
1. `make build` succeeds without errors
2. `qlmanage -p samples/comprehensive.md` shows:
   - Code blocks with uniform filled background (no white gaps between lines)
   - Blockquote with continuous blue vertical bar on left
   - No stray lines or rendering artifacts
3. Both light and dark mode render correctly (semantic colors)
</verification>

<success_criteria>
- Code block background is visually continuous (single filled area)
- Blockquote border is a continuous vertical bar
- No gaps, breaks, or artifacts in backgrounds/borders
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-markdown-rendering/02-08-SUMMARY.md`
</output>
