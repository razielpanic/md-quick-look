---
phase: 02-core-markdown-rendering
plan: 11
type: execute
wave: 1
depends_on: []
files_modified:
  - md-quick-look/MDQuickLook/MarkdownLayoutManager.swift
  - md-quick-look/MDQuickLook/MarkdownRenderer.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Blockquote left border is a continuous vertical bar without gaps"
    - "Blockquote background shading covers entire block width, not just text lines"
    - "No extra blank lines with shading appear between blockquote paragraphs"
  artifacts:
    - path: "md-quick-look/MDQuickLook/MarkdownLayoutManager.swift"
      provides: "Continuous blockquote border and background drawing"
      contains: "blockquoteMarker"
  key_links:
    - from: "MarkdownLayoutManager.drawBackground"
      to: "enumerateLineFragments"
      via: "Coalesced rect drawing"
      pattern: "unionRect"
---

<objective>
Fix blockquote rendering - continuous border, full-width background, no extra blank lines (Gap #16)

UAT round 4 found:
1. Left blue bar has gaps (not continuous)
2. Background shading only behind text lines (should be full-width block)
3. Extra blank line with shading between blockquote paragraphs

The LayoutManager union approach is in place but still has visual issues. The background shading comes from paragraph style (inline attributes) but should probably also be drawn by LayoutManager for consistency.

Purpose: Make blockquotes render with professional visual appearance
Output: Continuous border, uniform background, proper paragraph handling
</objective>

<execution_context>
@gsd:workflows/execute-plan.md
@gsd:templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-core-markdown-rendering/02-VERIFICATION-ROUND4.md
@md-quick-look/MDQuickLook/MarkdownLayoutManager.swift
@md-quick-look/MDQuickLook/MarkdownRenderer.swift
@samples/comprehensive.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Debug why blockquote border has gaps despite union approach</name>
  <files>md-quick-look/MDQuickLook/MarkdownLayoutManager.swift</files>
  <action>
The current implementation uses `enumerateLineFragments` with `unionRect` but UAT still shows gaps.

Debug hypotheses:

1. **Multiple blockquote attribute ranges**: If the renderer splits blockquote into multiple runs (e.g., different paragraphs), `enumerateAttribute` will enumerate each separately, drawing separate bars. Check if blockquote paragraphs have separate attribute ranges.

Add debug logging:
```swift
os_log("MarkdownLayoutManager: Drawing blockquote for char range %d-%d",
       log: .layoutManager, type: .debug,
       range.location, range.location + range.length)
```

2. **Coalesce ALL blockquote ranges**: If multiple blockquote ranges are found, they need to be combined before drawing:

```swift
// BEFORE enumeration - collect all blockquote ranges
var allBlockquoteRanges: [NSRange] = []

textStorage.enumerateAttribute(.blockquoteMarker,
                              in: charRange,
                              options: []) { value, range, _ in
    guard value != nil else { return }
    allBlockquoteRanges.append(range)
}

// Merge adjacent/overlapping ranges
let mergedRanges = mergeAdjacentRanges(allBlockquoteRanges)

// Then draw for each merged range
for range in mergedRanges {
    // ... existing drawing code with union
}
```

3. **Helper function to merge ranges**:
```swift
private func mergeAdjacentRanges(_ ranges: [NSRange]) -> [NSRange] {
    guard !ranges.isEmpty else { return [] }

    let sorted = ranges.sorted { $0.location < $1.location }
    var merged: [NSRange] = [sorted[0]]

    for range in sorted.dropFirst() {
        let last = merged.last!
        // If adjacent (within 2 characters for newlines) or overlapping
        if range.location <= last.location + last.length + 2 {
            // Extend the last range
            let newLength = max(last.length, range.location + range.length - last.location)
            merged[merged.count - 1] = NSRange(location: last.location, length: newLength)
        } else {
            merged.append(range)
        }
    }

    return merged
}
```

4. **Alternative: Draw based on PresentationIntent identity, not attribute enumeration**
The issue may be that blockquote paragraphs are separate attribute runs. Consider tracking by blockquote identity rather than attribute ranges.
  </action>
  <verify>Build with `make build`. Check Console.app for blockquote range logging. Run `qlmanage -p samples/comprehensive.md`. Verify: Left blue bar is continuous for entire blockquote (both paragraphs).</verify>
  <done>Blockquote left border renders as single continuous vertical bar</done>
</task>

<task type="auto">
  <name>Task 2: Fix blockquote background shading</name>
  <files>md-quick-look/MDQuickLook/MarkdownLayoutManager.swift, md-quick-look/MDQuickLook/MarkdownRenderer.swift</files>
  <action>
UAT reports: "Background shading only behind text lines (should be full-width block)"

Currently blockquote background is applied via paragraph style in MarkdownRenderer:
```swift
nsAttributedString.addAttribute(.backgroundColor, value: NSColor.quaternarySystemFill, range: range)
```

This creates inline background per-character, which looks fragmented. Instead:

1. **Remove inline backgroundColor from blockquotes** in MarkdownRenderer.swift:
```swift
private func applyBlockQuoteAttributes(to nsAttributedString: NSMutableAttributedString, range: NSRange) {
    // REMOVE this line:
    // nsAttributedString.addAttribute(.backgroundColor, value: NSColor.quaternarySystemFill, range: range)

    // Keep paragraph style and blockquoteMarker
    let paragraphStyle = NSMutableParagraphStyle()
    paragraphStyle.headIndent = 20
    paragraphStyle.firstLineHeadIndent = 20
    paragraphStyle.paragraphSpacing = 8
    paragraphStyle.paragraphSpacingBefore = 8
    nsAttributedString.addAttribute(.paragraphStyle, value: paragraphStyle, range: range)
    nsAttributedString.addAttribute(.blockquoteMarker, value: true, range: range)
}
```

2. **Draw full-width background in LayoutManager** (after drawing the border):
```swift
// After calculating unionRect for the blockquote...

// Draw full-width background first (behind border)
let bgRect = NSRect(x: origin.x + barX + barWidth + 4,  // Start after border
                   y: origin.y + unionRect.minY,
                   width: textContainer.containerSize.width - barX - barWidth - 12,
                   height: unionRect.height)

NSColor.quaternarySystemFill.setFill()
bgRect.fill()

// Then draw border on top
let barRect = NSRect(x: barX,
                    y: origin.y + unionRect.minY,
                    width: barWidth,
                    height: unionRect.height)

NSColor.systemBlue.withAlphaComponent(0.4).setFill()
barRect.fill()
```

This gives consistent full-width background that matches the border height.
  </action>
  <verify>Build with `make build`. Run `qlmanage -p samples/comprehensive.md`. Verify: Blockquote has uniform background fill extending full width, not just behind text characters.</verify>
  <done>Blockquote has uniform full-width background shading</done>
</task>

<task type="auto">
  <name>Task 3: Fix extra blank line in blockquotes</name>
  <files>md-quick-look/MDQuickLook/MarkdownRenderer.swift</files>
  <action>
UAT reports: "Extra blank line with shading between blockquote paragraphs"

This is likely from the newline insertion logic. The `ensureIntraBlockNewlines` function adds newlines after blockquote runs:

```swift
case .blockQuote:
    needsNewline = true
```

And `insertBlockBoundaryNewlines` adds newlines at block transitions.

Combined, multi-paragraph blockquotes get double-newlines between paragraphs.

Fix by checking the blockquote continuation more carefully:

1. In `ensureIntraBlockNewlines`, only add newline if this is the LAST line of a blockquote (not between blockquote paragraphs):

```swift
case .blockQuote:
    // Only insert newline if this is NOT followed by another blockquote run
    // (handled by checking next run, or skip blockquotes entirely here
    //  since block boundary handles it)
    needsNewline = false  // Let block boundary logic handle blockquotes
```

2. Or more precisely, track if the NEXT run is also a blockquote:
```swift
// In the run loop, peek at next run to decide
var runIndex = 0
let allRuns = Array(attributedString.runs)

for run in allRuns {
    // Check if next run is also blockquote
    let isLastBlockquoteRun: Bool
    if runIndex + 1 < allRuns.count {
        let nextRun = allRuns[runIndex + 1]
        let nextIsBlockquote = nextRun.presentationIntent?.components.contains { $0.kind == .blockQuote } ?? false
        isLastBlockquoteRun = !nextIsBlockquote
    } else {
        isLastBlockquoteRun = true
    }

    if component.kind == .blockQuote && isLastBlockquoteRun {
        needsNewline = true
    }

    runIndex += 1
}
```

The goal: Within a multi-paragraph blockquote, don't add extra newlines between paragraphs - just rely on the natural paragraph break.
  </action>
  <verify>Build with `make build`. Run `qlmanage -p samples/comprehensive.md`. Verify: Blockquote paragraphs ("This is a blockquote." / "It can span..." / "And have multiple paragraphs.") have normal spacing, no huge gaps.</verify>
  <done>Blockquote paragraphs have appropriate spacing without extra blank lines</done>
</task>

</tasks>

<verification>
1. `make build` succeeds without errors
2. `qlmanage -p samples/comprehensive.md` shows blockquotes with:
   - Continuous blue vertical bar on left (no gaps between lines)
   - Full-width subtle background (not just behind text)
   - Normal paragraph spacing (no extra blank lines with shading)
3. Both light and dark mode render correctly
</verification>

<success_criteria>
- Blockquote border: Single continuous blue vertical bar
- Blockquote background: Uniform fill extending full container width
- Blockquote spacing: Normal paragraph separation, no doubled gaps
- Visual appearance: Professional, clean rendering
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-markdown-rendering/02-11-SUMMARY.md`
</output>
