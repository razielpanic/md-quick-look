---
phase: 02-core-markdown-rendering
plan: 18
type: execute
wave: 1
depends_on: []
files_modified:
  - md-quick-look/MDQuickLook/MarkdownRenderer.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Unordered list item with inline formatting renders on single line"
    - "Each list item has exactly one bullet point"
    - "Inline bold/italic within list items does not cause line break"
  artifacts:
    - path: "md-quick-look/MDQuickLook/MarkdownRenderer.swift"
      provides: "Fixed ensureIntraBlockNewlines with ordinal tracking"
      contains: "ordinal tracking in ensureIntraBlockNewlines"
  key_links:
    - from: "ensureIntraBlockNewlines()"
      to: "list item ordinal comparison"
      via: "skip newline when next run has same ordinal"
      pattern: "currentListItemOrdinal.*previousListItemOrdinal"
---

<objective>
Fix unordered list inline formatting split (Gap #26)

Purpose: When a list item contains inline formatting (bold, italic), the item incorrectly splits across lines with duplicate bullets. The fix ensures inline formatting stays on the same line as its list item.

Output: List item "Third item with **bold**" renders as single line with one bullet.
</objective>

<execution_context>
@/Users/razielpanic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/razielpanic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-markdown-rendering/02-12-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ordinal tracking to ensureIntraBlockNewlines</name>
  <files>md-quick-look/MDQuickLook/MarkdownRenderer.swift</files>
  <action>
Modify the `ensureIntraBlockNewlines()` function (lines 176-230) to track list item ordinals across runs and only add newlines when the NEXT run is a DIFFERENT list item.

Current problem: The function adds a newline after every list item run unconditionally, even when the next run is part of the same list item (just with different inline formatting).

Solution pattern (similar to insertBlockBoundaryNewlines):
1. Extract the list item ordinal from each run's PresentationIntent components
2. When processing a list item run, peek ahead to the next run
3. If the next run has the SAME list item ordinal, do NOT add a newline
4. Only add a newline when:
   - This is the LAST run of the list item (next run has different ordinal), OR
   - This is the last run in the document, OR
   - The next run is not a list item

Implementation:
```swift
private func ensureIntraBlockNewlines(in attributedString: AttributedString) -> AttributedString {
    var result = attributedString
    var insertionPositions: [AttributedString.Index] = []

    // Collect all runs in array for peeking
    let allRuns = Array(attributedString.runs)

    // Helper to extract list item ordinal from a run
    func listItemOrdinal(for run: AttributedString.Runs.Run) -> Int? {
        guard let intent = run.presentationIntent else { return nil }
        for component in intent.components {
            if case .listItem(ordinal: let ordinal) = component.kind {
                return ordinal
            }
        }
        return nil
    }

    // Collect positions where newlines need to be inserted
    for (index, run) in allRuns.enumerated() {
        guard let intent = run.presentationIntent else { continue }

        // Check if this run contains a list item or blockquote
        var isListItem = false
        var isBlockquote = false
        var currentOrdinal: Int?

        for component in intent.components {
            switch component.kind {
            case .listItem(ordinal: let ordinal):
                isListItem = true
                currentOrdinal = ordinal
            case .blockQuote:
                isBlockquote = true
            default:
                break
            }
        }

        // For list items, only add newline if NEXT run is different list item
        if isListItem {
            let runText = String(attributedString[run.range].characters)
            if !runText.hasSuffix("\n") {
                // Peek at next run
                let nextIndex = index + 1
                if nextIndex < allRuns.count {
                    let nextOrdinal = listItemOrdinal(for: allRuns[nextIndex])
                    // Only add newline if next run has different ordinal (or no ordinal)
                    if nextOrdinal != currentOrdinal {
                        insertionPositions.append(run.range.upperBound)
                    }
                    // If same ordinal, skip - inline formatting continues on same line
                } else {
                    // Last run in document - add newline
                    insertionPositions.append(run.range.upperBound)
                }
            }
        }

        // For blockquotes, same logic as before
        if isBlockquote {
            let runText = String(attributedString[run.range].characters)
            if !runText.hasSuffix("\n") {
                insertionPositions.append(run.range.upperBound)
            }
        }
    }

    // Insert newlines in reverse order to maintain indices
    for insertPosition in insertionPositions.reversed() {
        result.insert(AttributedString("\n"), at: insertPosition)
        os_log("MarkdownRenderer: Inserted intra-block newline", log: .renderer, type: .debug)
    }

    return result
}
```

This mirrors the ordinal tracking pattern established in plan 02-12 for insertBlockBoundaryNewlines, but applies it to ensureIntraBlockNewlines.
  </action>
  <verify>
Build succeeds: `cd /Users/razielpanic/Projects/md-quick-look && make clean && make build`
  </verify>
  <done>
`ensureIntraBlockNewlines()` function updated with ordinal peek-ahead logic. Build compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Reinstall and verify rendering</name>
  <files>N/A - verification only</files>
  <action>
1. Install the updated extension: `make install`
2. Kill Quick Look to force reload: `pkill -9 -fi quicklook`
3. Preview the test file: `qlmanage -p samples/comprehensive.md`
4. Verify "Third item with **bold**" appears on a single line with one bullet

Expected result in Quick Look preview:
```
- First item
- Second item
- Third item with bold  (bold text styled, single line, ONE bullet)
- Fourth item
```

NOT:
```
- Third item with
- bold
```
  </action>
  <verify>
`qlmanage -p samples/comprehensive.md` shows list item "Third item with **bold**" on single line with one bullet point.
  </verify>
  <done>
List item with inline formatting renders on single line. Gap #26 closed.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds without warnings
2. Quick Look preview shows unordered list items correctly:
   - Each item has exactly one bullet
   - "Third item with **bold**" is on single line
   - Bold text is styled (heavier font weight)
3. Ordered lists still work (no regression from Test #6)
4. Blockquotes still work (no regression - newline logic preserved)
</verification>

<success_criteria>
- Gap #26 CLOSED: Unordered list inline formatting split fixed
- All 10 UAT tests should now pass
- No regressions in ordered lists, blockquotes, or other elements
- Phase 2 complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-markdown-rendering/02-18-SUMMARY.md`
</output>
