---
phase: 12-layout-sizing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - MDQuickLook/MDQuickLook Extension/MarkdownRenderer.swift
  - MDQuickLook/MDQuickLook Extension/TableRenderer.swift
autonomous: true

must_haves:
  truths:
    - "MarkdownRenderer accepts a WidthTier parameter and produces differently-sized output for narrow vs normal"
    - "All font sizes use tier-specific values with headings shrinking more aggressively than body text in narrow mode"
    - "No font size drops below 10pt in any tier"
    - "YAML front matter caps displayed fields at 5 in narrow mode with +N more indicator"
    - "Spacing and padding values throughout the renderer adapt to narrow mode"
    - "TableRenderer accepts widthTier and adjusts column constraints for narrow contexts"
  artifacts:
    - path: "MDQuickLook/MDQuickLook Extension/MarkdownRenderer.swift"
      provides: "WidthTier enum, width-aware render(markdown:widthTier:) API, tier-specific font/spacing lookups"
      contains: "enum WidthTier"
    - path: "MDQuickLook/MDQuickLook Extension/TableRenderer.swift"
      provides: "Width-aware table rendering with scaled constraints"
      contains: "widthTier"
  key_links:
    - from: "MarkdownRenderer.render(markdown:widthTier:)"
      to: "all apply*Attributes methods"
      via: "tier-specific font sizes and spacing values"
      pattern: "widthTier"
    - from: "MarkdownRenderer.renderFrontMatter"
      to: "WidthTier"
      via: "field capping and font scaling in narrow mode"
      pattern: "narrow.*more"
---

<objective>
Add width-tier awareness to the rendering pipeline so MarkdownRenderer and TableRenderer produce appropriately scaled output for narrow vs normal contexts.

Purpose: This is the rendering half of Phase 12 — making the content generation width-aware. All font sizes, spacing values, and layout decisions need to accept a WidthTier parameter and return different values for narrow vs normal mode. The view controller wiring (Plan 02) will pass the actual tier.

Output: WidthTier enum definition, width-aware MarkdownRenderer.render(markdown:widthTier:) API, tier-specific font/spacing for every styled element, width-adapted YAML front matter rendering, width-adapted TableRenderer.
</objective>

<execution_context>
@/Users/razielpanic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/razielpanic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-layout-sizing/12-CONTEXT.md
@.planning/phases/12-layout-sizing/12-RESEARCH.md
@MDQuickLook/MDQuickLook Extension/MarkdownRenderer.swift
@MDQuickLook/MDQuickLook Extension/TableRenderer.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WidthTier enum and refactor MarkdownRenderer for width-aware rendering</name>
  <files>MDQuickLook/MDQuickLook Extension/MarkdownRenderer.swift</files>
  <action>
  Define a `WidthTier` enum at the top of MarkdownRenderer.swift (outside the class, so PreviewViewController and TableRenderer can use it):

  ```swift
  enum WidthTier {
      case narrow   // Finder preview pane (~260px)
      case normal   // Quick Look popup, fullscreen
  }
  ```

  Replace the hardcoded font size properties with a tier-aware approach. Keep the existing properties as the `.normal` defaults. Add a stored `widthTier` property to MarkdownRenderer and a convenience initializer or setter.

  **Font sizes for narrow mode** (headings shrink 30-40%, body/code shrink ~15%, floor at 10pt):
  - h1: 20 (was 32, -37.5%), h2: 17 (was 26, -34.6%), h3: 15 (was 22, -31.8%)
  - h4: 14 (was 18, -22%), h5: 13 (was 16, -19%), h6: 12 (was 14, -14%)
  - body: 12 (was 14, -14%), code: 11 (was 13, -15%)
  - All above 10pt floor -- good.

  **Heading spacing for narrow mode** (shrink proportionally):
  - h1: 6 (was 12), h2: 5 (was 10), h3: 4 (was 8), h4: 3 (was 6), h5: 2 (was 4), h6: 2 (was 4)

  Create computed properties or helper methods that return the correct values based on widthTier:

  ```swift
  private var currentHeadingSizes: [Int: CGFloat] {
      switch widthTier {
      case .narrow:
          return [1: 20.0, 2: 17.0, 3: 15.0, 4: 14.0, 5: 13.0, 6: 12.0]
      case .normal:
          return [1: 32.0, 2: 26.0, 3: 22.0, 4: 18.0, 5: 16.0, 6: 14.0]
      }
  }
  ```

  Similarly for `currentHeadingSpacing`, `currentBodyFontSize` (14 normal, 12 narrow), `currentCodeFontSize` (13 normal, 11 narrow).

  **Update the public API:**
  - Change `render(markdown:)` signature to `render(markdown: String, widthTier: WidthTier = .normal) -> NSAttributedString`
  - Store widthTier as instance property at the start of render: `self.widthTier = widthTier`
  - This preserves backward compatibility (default .normal).

  **Update every method that uses hardcoded font sizes or spacing** to use the tier-aware computed properties instead:

  1. `applyHeadingAttributes` — use `currentHeadingSizes[level]` and `currentHeadingSpacing[level]`
  2. `applyCodeBlockAttributes` — use `currentCodeFontSize` instead of hardcoded 13. Narrow padding: headIndent 6 (was 10), paragraphSpacing 4 (was 8), paragraphSpacingBefore 4 (was 8).
  3. `applyInlineCodeAttributes` — use `currentCodeFontSize` instead of hardcoded 13
  4. `applyListItemAttributes` — narrow: firstLineHeadIndent 10 (was 20), headIndent 18 (was 30), tabStop at 18 (was 30), lineSpacing 1 (was 2)
  5. `applyBlockQuoteAttributes` — narrow: headIndent 12 (was 20), firstLineHeadIndent 12 (was 20), paragraphSpacing 4 (was 8), paragraphSpacingBefore 4 (was 8)
  6. `applyBaseStyles` — use `currentBodyFontSize` instead of `bodyFontSize`, narrow paragraphSpacing 4 (was 8)
  7. `insertListPrefixes` — use `currentBodyFontSize` for prefix font, narrow: firstLineHeadIndent 10 (was 20), headIndent 18 (was 30), tabStop at 18 (was 30), lineSpacing 1 (was 2)
  8. `applyImagePlaceholderStyles` — use `currentBodyFontSize` for symbol config and placeholder text font
  9. `renderNonTableSegment` — already calls the above methods, so it will inherit tier awareness automatically (as long as widthTier is stored on the instance)

  **Update renderFrontMatter for narrow mode** — this is the most significant change:

  For narrow mode:
  - Font size: 10pt (was 12pt) for both keys and values
  - Cap displayed fields at 5. If frontMatter.count > 5, only render first 5 and append a "+N more" line.
  - Always use single-column layout in narrow mode (two columns won't fit in ~260px)
  - Tighter spacing: headIndent 8 (was 20), firstLineHeadIndent 8 (was 20), tailIndent -8 (was -20), paragraphSpacing 2 (was 4), paragraphSpacingBefore 2 (was 4)
  - Tab stop at 80 (was 120) for value column in narrow mode
  - Keep .byTruncatingTail (already present)
  - Keep .frontMatterMarker (already present)
  - Spacer line: minimumLineHeight 4 (was 8) in narrow mode

  For the "+N more" indicator in narrow mode:
  ```swift
  if widthTier == .narrow && frontMatter.count > maxDisplayedFields {
      let hiddenCount = frontMatter.count - maxDisplayedFields
      let moreText = NSAttributedString(string: "+\(hiddenCount) more\n", attributes: [
          .font: NSFont.systemFont(ofSize: 10),
          .foregroundColor: NSColor.tertiaryLabelColor
      ])
      result.append(moreText)
  }
  ```

  For normal mode: renderFrontMatter stays as-is (existing implementation).

  Keep the original `headingSizes`, `headingSpacing`, `bodyFontSize` properties as documentation/reference but route all usage through the tier-aware computed properties.
  </action>
  <verify>
  Build succeeds: `cd /Users/razielpanic/Projects/md-spotlighter && make build`

  Verify no hardcoded font sizes remain in style methods:
  - Search for `ofSize: 13` in MarkdownRenderer.swift (should only appear in computed property, not in apply* methods)
  - Search for `ofSize: 14` — same check
  - `headIndent = 20` should only appear in normal-mode paths or computed properties
  </verify>
  <done>
  MarkdownRenderer has a WidthTier enum, accepts widthTier parameter in render(), and every style application method uses tier-specific font sizes and spacing. Narrow mode produces smaller fonts (headings 20/17/15/14/13/12, body 12, code 11), tighter spacing, and YAML front matter is capped at 5 fields with +N more indicator. Normal mode produces identical output to current behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update TableRenderer for width-aware rendering</name>
  <files>MDQuickLook/MDQuickLook Extension/TableRenderer.swift</files>
  <action>
  Update TableRenderer to accept a widthTier parameter:

  1. Add a `widthTier` property (default `.normal`):
     ```swift
     var widthTier: WidthTier = .normal
     ```

  2. Add a convenience initializer:
     ```swift
     init(widthTier: WidthTier = .normal) {
         self.widthTier = widthTier
     }
     ```

  3. Make font size tier-aware:
     - Normal: bodyFontSize = 14 (unchanged)
     - Narrow: bodyFontSize = 12

     Replace the hardcoded `bodyFontSize` property with a computed property:
     ```swift
     private var bodyFontSize: CGFloat {
         widthTier == .narrow ? 12.0 : 14.0
     }
     ```

  4. Update `measureColumnWidths` constraints for narrow mode:
     - Narrow: minColumnWidth 40 (was 60), maxColumnWidth 150 (was 300), maxTableWidth 400 (was 800)
     - Normal: unchanged (60, 300, 800)
     - Breathing room: narrow 10 (was 20), normal 20 (unchanged)

  5. Update `renderCell` padding for narrow mode:
     - Narrow: 3pt padding on all edges (was 6pt)
     - Normal: 6pt unchanged

  6. Update MarkdownRenderer's `renderWithSourceRanges` and `renderWithPlaceholders` to pass widthTier when creating TableRenderer:
     In MarkdownRenderer.swift, change `let tableRenderer = TableRenderer()` to `let tableRenderer = TableRenderer(widthTier: widthTier)` in both methods.
  </action>
  <verify>
  Build succeeds: `cd /Users/razielpanic/Projects/md-spotlighter && make build`

  Check that TableRenderer no longer has a hardcoded `bodyFontSize` constant (should be computed property).
  </verify>
  <done>
  TableRenderer accepts WidthTier, uses 12pt font in narrow mode, constrains columns more tightly (min 40, max 150, total 400), uses 3pt cell padding in narrow mode. MarkdownRenderer passes its widthTier to TableRenderer when creating instances.
  </done>
</task>

</tasks>

<verification>
- `make build` succeeds with zero errors
- MarkdownRenderer.render(markdown:widthTier:) compiles and accepts both .narrow and .normal
- All apply* methods reference tier-aware computed properties, not hardcoded literals
- TableRenderer(widthTier:) compiles and produces different output per tier
- Default behavior (widthTier: .normal) matches current rendering exactly (no regression)
</verification>

<success_criteria>
- WidthTier enum defined and accessible to both MarkdownRenderer and PreviewViewController
- render(markdown:widthTier:) API exists with .normal default
- Every hardcoded font size and spacing value in MarkdownRenderer style methods routes through tier-aware properties
- Narrow YAML front matter caps at 5 fields with "+N more" indicator
- Narrow mode forces single-column YAML layout
- TableRenderer scales font, column widths, and cell padding for narrow mode
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-layout-sizing/12-01-SUMMARY.md`
</output>
