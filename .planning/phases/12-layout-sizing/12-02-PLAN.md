---
phase: 12-layout-sizing
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - MDQuickLook/MDQuickLook Extension/PreviewViewController.swift
  - MDQuickLook/MDQuickLook Extension/MarkdownLayoutManager.swift
autonomous: false

must_haves:
  truths:
    - "Extension detects narrow contexts (Finder preview pane) and produces appropriately scaled rendering"
    - "Extension detects normal/wide contexts and renders with standard sizes plus max content width cap"
    - "Switching between contexts does not break rendering (no stale tier state)"
    - "LayoutManager background positions adapt to narrow mode insets"
    - "Quick Look window sizing remains system-managed with no preferredContentSize"
  artifacts:
    - path: "MDQuickLook/MDQuickLook Extension/PreviewViewController.swift"
      provides: "Width detection in viewDidLayout, tier-aware rendering dispatch, dynamic textContainerInset, max content width cap"
      contains: "viewDidLayout"
    - path: "MDQuickLook/MDQuickLook Extension/MarkdownLayoutManager.swift"
      provides: "Width-tier-aware background drawing positions"
      contains: "widthTier"
  key_links:
    - from: "PreviewViewController.viewDidLayout()"
      to: "MarkdownRenderer.render(markdown:widthTier:)"
      via: "width tier detection and content regeneration"
      pattern: "render.*widthTier"
    - from: "PreviewViewController"
      to: "MarkdownLayoutManager.widthTier"
      via: "property assignment when tier changes"
      pattern: "layoutManager.*widthTier"
    - from: "PreviewViewController.viewDidLayout()"
      to: "textView.textContainerInset"
      via: "dynamic inset based on tier and max content width"
      pattern: "textContainerInset"
---

<objective>
Wire up width detection in PreviewViewController, adapt MarkdownLayoutManager backgrounds for narrow insets, and verify the complete layout adaptation visually.

Purpose: This is the view/controller half of Phase 12 — detecting the available width, determining the tier, passing it to the renderer (from Plan 01), adjusting text container insets, and adapting LayoutManager background drawing positions. Also adds max content width cap in normal mode for readable line lengths in fullscreen.

Output: Working width-adaptive Quick Look extension that produces readable output in both narrow Finder preview pane and wide/fullscreen contexts.
</objective>

<execution_context>
@/Users/razielpanic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/razielpanic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-layout-sizing/12-CONTEXT.md
@.planning/phases/12-layout-sizing/12-RESEARCH.md
@.planning/phases/12-layout-sizing/12-01-SUMMARY.md
@MDQuickLook/MDQuickLook Extension/PreviewViewController.swift
@MDQuickLook/MDQuickLook Extension/MarkdownLayoutManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add width detection to PreviewViewController and adapt MarkdownLayoutManager</name>
  <files>MDQuickLook/MDQuickLook Extension/PreviewViewController.swift, MDQuickLook/MDQuickLook Extension/MarkdownLayoutManager.swift</files>
  <action>
  **PreviewViewController.swift changes:**

  The current `preparePreviewOfFile` creates all views locally in the method. To support re-rendering on tier change, store references as instance properties.

  Add instance properties:
  ```swift
  private var currentWidthTier: WidthTier?
  private var markdownContent: String?
  private var scrollView: NSScrollView?
  private var textView: NSTextView?
  private var textStorage: NSTextStorage?
  private var mdLayoutManager: MarkdownLayoutManager?
  ```

  **Narrow threshold:** Use 320pt. The Finder preview pane is ~260px and is the primary narrow context. 320pt gives comfortable margin above that while correctly classifying Quick Look popup windows (typically 500px+) as normal.

  Add `viewDidLayout()` override:
  ```swift
  override func viewDidLayout() {
      super.viewDidLayout()

      let availableWidth = view.bounds.width
      let newTier: WidthTier = availableWidth < 320 ? .narrow : .normal

      // Only regenerate if tier actually changed
      guard newTier != currentWidthTier else {
          // Even if tier didn't change, update insets for normal mode (max content width)
          updateInsetsForWidth(availableWidth, tier: newTier)
          return
      }

      currentWidthTier = newTier
      os_log("Width tier changed to %{public}s (width: %.0f)", log: .quicklook, type: .info,
             newTier == .narrow ? "narrow" : "normal", availableWidth)

      regenerateContent()
  }
  ```

  Add helper to update insets dynamically:
  ```swift
  private func updateInsetsForWidth(_ availableWidth: CGFloat, tier: WidthTier) {
      guard let textView = textView else { return }

      switch tier {
      case .narrow:
          textView.textContainerInset = NSSize(width: 6, height: 6)
      case .normal:
          // Max content width cap: ~75 chars at 14pt body font
          // Average char width for system font at 14pt is approximately 7.5pt
          let maxContentWidth: CGFloat = 640  // ~75 chars * ~8.5pt avg width
          let totalInsetWidth = maxContentWidth + 40  // 40 for minimum 20pt each side

          if availableWidth > totalInsetWidth {
              let horizontalInset = (availableWidth - maxContentWidth) / 2
              textView.textContainerInset = NSSize(width: horizontalInset, height: 20)
          } else {
              textView.textContainerInset = NSSize(width: 20, height: 20)
          }
      }

      // Update text container width to account for new insets
      if let textContainer = textView.textContainer {
          textContainer.containerSize = NSSize(
              width: textView.bounds.width - textView.textContainerInset.width * 2,
              height: CGFloat.greatestFiniteMagnitude
          )
      }
  }
  ```

  Add helper to regenerate content with current tier:
  ```swift
  private func regenerateContent() {
      guard let markdownContent = markdownContent,
            let textStorage = textStorage,
            let textView = textView,
            let tier = currentWidthTier else { return }

      // Update LayoutManager tier
      mdLayoutManager?.widthTier = tier

      // Update insets first
      updateInsetsForWidth(view.bounds.width, tier: tier)

      // Re-render with new tier
      let renderer = MarkdownRenderer()
      let styledContent = renderer.render(markdown: markdownContent, widthTier: tier)
      textStorage.setAttributedString(styledContent)

      // Force layout
      if let layoutManager = textView.layoutManager {
          layoutManager.ensureLayout(forCharacterRange: NSRange(location: 0, length: textStorage.length))
      }

      os_log("Content regenerated for %{public}s tier", log: .quicklook, type: .info,
             tier == .narrow ? "narrow" : "normal")
  }
  ```

  **Refactor preparePreviewOfFile:**
  - After creating scrollView, textView, textStorage, layoutManager — store them in instance properties
  - Store markdownContent for re-rendering
  - Use initial width detection to determine starting tier (don't wait for viewDidLayout):
    ```swift
    let initialTier: WidthTier = view.bounds.width < 320 ? .narrow : .normal
    currentWidthTier = initialTier
    ```
  - Pass widthTier to renderer: `renderer.render(markdown: markdownContent, widthTier: initialTier)`
  - Set initial textContainerInset based on tier (narrow: 6,6 / normal: 20,20)
  - Set LayoutManager tier: `layoutManager.widthTier = initialTier`
  - Update textContainer width calculation: `scrollView.contentSize.width - (initialTier == .narrow ? 12 : 40)` to account for tier-specific insets
  - Store `layoutManager` as `mdLayoutManager` property

  IMPORTANT: Do NOT set preferredContentSize anywhere. Window sizing must remain system-managed. The current autoresizingMask approach (`scrollView.autoresizingMask = [.width, .height]`) is correct and must be preserved.

  **MarkdownLayoutManager.swift changes:**

  Add a `widthTier` property:
  ```swift
  var widthTier: WidthTier = .normal
  ```

  Update `drawBackground(forGlyphRange:at:)` to use tier-aware positions.

  For **blockquote** background drawing:
  - Narrow: bgRect x offset 4 (was 12), width padding 8 (was 24), bar x offset 2 (was 4)
  - Normal: unchanged (12, 24, 4)

  For **code block** background drawing:
  - Narrow: bgRect x offset 4 (was 8), width padding 8 (was 16)
  - Normal: unchanged (8, 16)

  For **front matter** background drawing:
  - Narrow: bgRect x offset 3 (was 6), width padding 6 (was 12), verticalPadding 6 (was 12), cornerRadius 4 (was 6)
  - Normal: unchanged (6, 12, 12, 6)
  - Separator line: narrow x offsets 3 (was 6)

  Use a helper or inline switch to get the tier-specific values. Example pattern:
  ```swift
  let (bgXOffset, bgWidthPadding, barXOffset): (CGFloat, CGFloat, CGFloat) = {
      switch widthTier {
      case .narrow: return (4, 8, 2)
      case .normal: return (12, 24, 4)
      }
  }()
  ```
  </action>
  <verify>
  Build succeeds: `cd /Users/razielpanic/Projects/md-spotlighter && make build`

  Check that:
  - `preferredContentSize` does NOT appear anywhere in PreviewViewController.swift
  - `viewDidLayout` override exists
  - `currentWidthTier` property exists
  - MarkdownLayoutManager has `widthTier` property
  - `autoresizingMask = [.width, .height]` still present on scrollView
  </verify>
  <done>
  PreviewViewController detects width tier changes in viewDidLayout(), regenerates content when tier transitions between narrow and normal, applies tier-specific textContainerInset (6pt narrow, 20pt+ normal with max content width cap), and passes tier to both MarkdownRenderer and MarkdownLayoutManager. LayoutManager draws backgrounds at tier-appropriate positions. No preferredContentSize is set. Build passes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete width-adaptive rendering system: the extension detects narrow contexts (Finder preview pane) and normal/wide contexts (spacebar popup, fullscreen), scales fonts, spacing, padding, YAML front matter, table sizing, and background decorations accordingly. Normal mode includes max content width cap for readable line lengths in fullscreen.</what-built>
  <how-to-verify>
  Build and install the extension, then test with a markdown file that has YAML front matter, headings, code blocks, blockquotes, lists, and a table (the samples/yaml-front-matter.md file is good, or create a comprehensive test file).

  1. **Build and install:**
     ```
     cd /Users/razielpanic/Projects/md-spotlighter && make build && make install
     ```
     Then run: `make reload` to refresh the Quick Look extension.

  2. **Test normal mode (spacebar popup):**
     - Select a markdown file in Finder and press spacebar
     - Verify: headings are large (H1 ~32pt), body text is readable (~14pt)
     - Verify: standard padding around content (~20pt margins)
     - Verify: YAML front matter shows all fields with two-column layout for 4+ pairs
     - Verify: code blocks and blockquotes have proper background fills

  3. **Test narrow mode (Finder preview pane):**
     - In Finder, switch to column view (Cmd+3)
     - Select a markdown file to show it in the preview pane
     - Verify: headings are noticeably smaller than popup mode but still readable
     - Verify: body text is slightly smaller but legible
     - Verify: margins are minimal (content nearly edge-to-edge)
     - Verify: YAML front matter uses smaller font, single-column layout
     - Verify: if file has 6+ front matter fields, only 5 show with "+N more" indicator
     - Verify: code block and blockquote backgrounds extend closer to edges

  4. **Test fullscreen mode:**
     - From spacebar popup, click the fullscreen button
     - Verify: text does NOT stretch uncomfortably wide across the entire screen
     - Verify: content is centered with comfortable reading width (~75 chars per line)
     - Verify: all elements render correctly at this width

  5. **Test no regression on files without front matter:**
     - Preview samples/no-front-matter.md in spacebar popup
     - Verify: renders identically to before these changes
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with the rendering in any context</resume-signal>
</task>

</tasks>

<verification>
- `make build` succeeds with zero errors
- `make install` succeeds
- Extension loads in all three contexts: spacebar popup, Finder preview pane, fullscreen
- Narrow mode: smaller fonts, tighter spacing, minimal margins, YAML capped at 5 fields
- Normal mode: standard fonts, standard spacing, max content width cap in fullscreen
- No preferredContentSize set (system manages window sizing)
- viewDidLayout only regenerates content on tier CHANGE, not every bounds update
- Files without front matter render identically to pre-Phase-12 behavior
</verification>

<success_criteria>
- LAYOUT-01: Quick Look window sizing remains system-managed (no preferredContentSize, autoresizing preserved)
- LAYOUT-02: Extension detects narrow contexts via view.bounds.width < 320 and passes tier to renderer
- LAYOUT-03: Font sizes scale down in narrow mode (headings 20/17/15, body 12, code 11) with 10pt floor
- LAYOUT-04: Text container insets shrink to 6pt in narrow mode, maximizing content visibility
- Normal mode adds max content width cap (~640pt) to prevent uncomfortably long lines in fullscreen
- YAML front matter adapts: smaller font, single-column, 5-field cap with +N more in narrow mode
- LayoutManager background positions adapt to tier-specific insets
- Human verified in all three contexts (popup, preview pane, fullscreen)
</success_criteria>

<output>
After completion, create `.planning/phases/12-layout-sizing/12-02-SUMMARY.md`
</output>
