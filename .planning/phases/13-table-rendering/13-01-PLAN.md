---
phase: 13-table-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - MDQuickLook/MDQuickLook Extension/TableRenderer.swift
  - MDQuickLook/MDQuickLook Extension/MarkdownRenderer.swift
  - MDQuickLook/MDQuickLook Extension/PreviewViewController.swift
autonomous: true

must_haves:
  truths:
    - "Table total width scales to match available container width instead of using hardcoded maxTableWidth caps"
    - "Column widths are content-proportional — wider content gets more space, but all columns respect min/max constraints"
    - "Content-fitted tables: tables only as wide as their content needs, compact tables do not expand to fill container"
    - "Maximum table width matches the body content cap (640pt) in normal mode"
    - "Compact mode activates in narrow WidthTier with smaller font (11pt), reduced padding (2pt), and thinner borders (1pt)"
    - "Tables with 5+ columns still render with proportionally scaled columns, not crushed or overflowing"
  artifacts:
    - path: "MDQuickLook/MDQuickLook Extension/TableRenderer.swift"
      provides: "Available-width-aware table rendering with content-proportional columns and compact mode"
      contains: "availableWidth"
    - path: "MDQuickLook/MDQuickLook Extension/MarkdownRenderer.swift"
      provides: "Passes availableWidth from text container to TableRenderer"
      contains: "availableWidth"
    - path: "MDQuickLook/MDQuickLook Extension/PreviewViewController.swift"
      provides: "Passes available content width to MarkdownRenderer"
      contains: "availableWidth"
  key_links:
    - from: "PreviewViewController"
      to: "MarkdownRenderer.render(markdown:widthTier:availableWidth:)"
      via: "calculated content width from text container"
      pattern: "availableWidth"
    - from: "MarkdownRenderer.renderWithSourceRanges/renderWithPlaceholders"
      to: "TableRenderer(widthTier:availableWidth:)"
      via: "forwarding available width to table renderer"
      pattern: "availableWidth"
    - from: "TableRenderer.measureColumnWidths"
      to: "TableRenderer.render"
      via: "content-proportional widths capped by available width"
      pattern: "availableWidth"
---

<objective>
Enhance TableRenderer to use actual available container width for table sizing, implement content-proportional column widths with proper min/max constraints, and activate compact mode in narrow contexts.

Purpose: Tables currently use hardcoded maxTableWidth caps (400/800pt) that don't respond to actual container size. This plan makes tables width-aware by threading available width through the rendering pipeline and using it for proportional column measurement. Compact mode ensures tables remain readable even in the narrowest Finder preview pane.

Output: TableRenderer that accepts availableWidth, produces content-fitted tables that scale proportionally to available space, and activates compact styling (smaller font, reduced padding, thinner borders) in narrow mode.
</objective>

<execution_context>
@/Users/razielpanic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/razielpanic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-table-rendering/13-CONTEXT.md
@.planning/phases/13-table-rendering/13-RESEARCH.md
@MDQuickLook/MDQuickLook Extension/TableRenderer.swift
@MDQuickLook/MDQuickLook Extension/MarkdownRenderer.swift
@MDQuickLook/MDQuickLook Extension/PreviewViewController.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Thread availableWidth through the rendering pipeline</name>
  <files>
    MDQuickLook/MDQuickLook Extension/PreviewViewController.swift
    MDQuickLook/MDQuickLook Extension/MarkdownRenderer.swift
    MDQuickLook/MDQuickLook Extension/TableRenderer.swift
  </files>
  <action>
  Thread an `availableWidth` parameter from PreviewViewController through MarkdownRenderer to TableRenderer. This provides the actual pixel width the table can occupy.

  **PreviewViewController changes:**
  1. In `preparePreviewOfFile`, after creating the text view and computing insets, calculate the available content width:
     ```swift
     let availableContentWidth = scrollView.contentSize.width - (textView.textContainerInset.width * 2)
     ```
  2. Pass this to `renderer.render(markdown:widthTier:availableWidth:)`.
  3. Store `availableContentWidth` as an instance property for use during re-renders.
  4. In `regenerateContent()`, recalculate available content width from current text view state and pass to render.

  **MarkdownRenderer changes:**
  1. Add a stored property `private var availableWidth: CGFloat = 640` (default matches normal mode max).
  2. Update `render(markdown:widthTier:)` signature to `render(markdown: String, widthTier: WidthTier = .normal, availableWidth: CGFloat = 640) -> NSAttributedString`.
  3. Store `self.availableWidth = availableWidth` at top of render method.
  4. In `renderWithSourceRanges` and `renderWithPlaceholders`, pass availableWidth when creating TableRenderer:
     ```swift
     let tableRenderer = TableRenderer(widthTier: widthTier, availableWidth: availableWidth)
     ```

  **TableRenderer changes:**
  1. Add a stored property `var availableWidth: CGFloat = 640`.
  2. Update the initializer:
     ```swift
     init(widthTier: WidthTier = .normal, availableWidth: CGFloat = 640) {
         self.widthTier = widthTier
         self.availableWidth = availableWidth
     }
     ```
  3. The `availableWidth` will be consumed by measureColumnWidths in Task 2 — for now just wire it through.
  </action>
  <verify>
  Build succeeds: `cd /Users/razielpanic/Projects/md-spotlighter && make build`

  Verify the parameter flows through:
  - PreviewViewController passes availableWidth to MarkdownRenderer
  - MarkdownRenderer passes availableWidth to TableRenderer
  - All three files reference availableWidth
  </verify>
  <done>
  Available container width flows from PreviewViewController through MarkdownRenderer to TableRenderer. All three files compile with the new parameter. Default value (640) preserves backward compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement content-proportional column sizing and compact mode</name>
  <files>MDQuickLook/MDQuickLook Extension/TableRenderer.swift</files>
  <action>
  Rewrite `measureColumnWidths` and update `renderCell` to implement content-proportional column sizing with available-width scaling and compact mode.

  **Compact mode constants** (narrow tier produces compact tables per user decision):

  | Property | Compact (narrow) | Normal |
  |----------|------------------|--------|
  | bodyFontSize | 11.0 | 14.0 |
  | cellPadding | 2.0 | 6.0 |
  | breathingRoom | 6.0 | 16.0 |
  | minColumnWidth | 30.0 | 50.0 |
  | maxColumnWidth | 120.0 | 280.0 |
  | headerBorderWidth | 1.0 | 2.0 |

  Update the `bodyFontSize` computed property from `widthTier == .narrow ? 12.0 : 14.0` to `widthTier == .narrow ? 11.0 : 14.0` (compact mode per user decision: smaller font for max data density).

  **Rewrite `measureColumnWidths(for:columnCount:)`:**

  1. Measure raw content width per column using NSString.size(withAttributes:) — keep existing measurement logic.

  2. Add padding and breathing room (tier-aware as above).

  3. Apply min/max column constraints (tier-aware as above).

  4. Calculate total measured width (sum of all column widths).

  5. Determine the max table width: `min(availableWidth, 640.0)` in normal mode, `availableWidth` in narrow mode (no cap needed since narrow is already constrained). The 640pt cap matches the body content max width per user decision.

  6. **Content-fitted logic (per user decision: tables only as wide as needed)**:
     - If total measured width <= max table width: use measured widths as-is (table stays compact).
     - If total measured width > max table width: scale ALL columns proportionally to fit within max table width. After scaling, re-enforce min column width — if any column falls below min, set it to min and redistribute the remaining space proportionally among the other columns.

  7. **High column count handling (5+ columns, Claude's discretion):**
     - For 5+ columns in normal mode: reduce maxColumnWidth to `min(maxColumnWidth, maxTableWidth / CGFloat(columnCount) * 1.5)` so no single column dominates. This allows the widest column to be at most 1.5x the equal-share width.
     - For 5+ columns in narrow mode: same formula but using narrow maxColumnWidth.

  **Update `renderCell`:**

  1. Cell padding: use `widthTier == .narrow ? 2.0 : 6.0` (was 3.0/6.0 — reduced for compact mode).

  2. Header border thickness: use `widthTier == .narrow ? 1.0 : 2.0` (was always 2.0 — reduced for compact mode per user decision).

  3. Border color: use `NSColor.separatorColor` (already present, adapts to dark mode automatically). This is fine as-is — NSColor.separatorColor provides good contrast in both light and dark mode.

  **Update `render(_ table:)`:**

  After calculating `totalWidth`, cap it: `let cappedWidth = min(totalWidth, widthTier == .narrow ? availableWidth : min(availableWidth, 640.0))`. Use `cappedWidth` for `nsTable.setContentWidth`.
  </action>
  <verify>
  Build succeeds: `cd /Users/razielpanic/Projects/md-spotlighter && make build`

  Verify key behaviors by reading the code:
  - measureColumnWidths uses availableWidth, not hardcoded 400/800
  - Content-fitted: total width is NOT forced to expand when columns are small
  - Proportional scaling: when total > maxTableWidth, all columns scale down
  - Compact mode: narrow tier uses 11pt font, 2pt padding, 1pt border
  - High column count: 5+ columns get capped max column width
  </verify>
  <done>
  TableRenderer produces content-proportional column widths that scale to available container width. Compact tables stay compact (content-fitted). When content exceeds available width, columns scale proportionally while respecting minimum widths. Compact mode in narrow tier uses 11pt font, 2pt padding, and 1pt header border. High column count (5+) tables cap individual column width to prevent dominance.
  </done>
</task>

</tasks>

<verification>
- `make build` succeeds with zero errors
- availableWidth flows from PreviewViewController -> MarkdownRenderer -> TableRenderer
- TableRenderer.measureColumnWidths uses availableWidth instead of hardcoded 400/800 caps
- Content-fitted tables: small tables don't expand to fill container
- Compact mode (narrow tier): 11pt font, 2pt padding, 1pt border, 30pt min column, 120pt max column
- Normal mode: 14pt font, 6pt padding, 2pt border, 50pt min column, 280pt max column, 640pt max table width
- Proportional scaling when content exceeds max width
- High column count (5+) handling prevents column dominance
- Default parameter values preserve backward compatibility
</verification>

<success_criteria>
- Available container width is threaded through the full rendering pipeline
- Table widths scale to available space, not hardcoded maxima
- Column widths are content-proportional with enforced min/max constraints
- Compact mode activates in narrow tier with smaller font, tighter padding, thinner borders
- Content-fitted: tables only as wide as content needs
- Max table width in normal mode matches body content cap (640pt)
- High column count tables (5+) render with balanced column widths
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-table-rendering/13-01-SUMMARY.md`
</output>
