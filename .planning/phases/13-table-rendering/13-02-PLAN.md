---
phase: 13-table-rendering
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - MDQuickLook/MDQuickLook Extension/TableRenderer.swift
autonomous: true

must_haves:
  truths:
    - "Cells truncate by default with ellipsis for tight scannable rows"
    - "Wrapping activates ONLY when most cells (>50%) in a row would benefit from it, preventing lopsided tall rows"
    - "When wrapping is allowed, cell content caps at 3 lines maximum"
    - "Long unbreakable strings (URLs, paths) always truncate, never mid-break"
    - "GFM column alignment markers (left/center/right) are correctly applied to cell paragraph style"
    - "Tables in Finder preview pane (~260px) are readable with all cell content visible or truncated with ellipsis"
  artifacts:
    - path: "MDQuickLook/MDQuickLook Extension/TableRenderer.swift"
      provides: "Smart wrap/truncate hybrid with row-level wrapping decisions and 3-line cap"
      contains: "shouldWrapRow"
  key_links:
    - from: "TableRenderer.render"
      to: "TableRenderer.shouldWrapRow"
      via: "per-row wrapping decision based on cell overflow analysis"
      pattern: "shouldWrapRow"
    - from: "TableRenderer.renderCell"
      to: "NSParagraphStyle.lineBreakMode"
      via: "truncation or wrapping based on row-level decision"
      pattern: "lineBreakMode"
---

<objective>
Implement smart wrap/truncate hybrid logic for table cells so rows stay tight and scannable by default, with wrapping only when it benefits the majority of cells in a row.

Purpose: Plan 01 establishes proper table sizing and compact mode. This plan adds intelligent cell content overflow handling — the key to making tables readable across all contexts. Truncation keeps rows compact by default, but when a row has many overflowing cells, wrapping prevents information loss. The 3-line cap prevents any single cell from creating excessively tall rows.

Output: TableRenderer with smart per-row wrap/truncate decisions, 3-line wrapping cap, unbreakable string protection, and full GFM alignment support.
</objective>

<execution_context>
@/Users/razielpanic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/razielpanic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-table-rendering/13-CONTEXT.md
@.planning/phases/13-table-rendering/13-RESEARCH.md
@.planning/phases/13-table-rendering/13-01-SUMMARY.md
@MDQuickLook/MDQuickLook Extension/TableRenderer.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement smart wrap/truncate hybrid with row-level decisions</name>
  <files>MDQuickLook/MDQuickLook Extension/TableRenderer.swift</files>
  <action>
  Add a row-level wrap/truncate decision system to TableRenderer. The goal: rows stay tight by default (truncation), but when most cells in a row overflow, wrapping activates to preserve information — capped at 3 lines to prevent excessively tall rows.

  **Add a helper method `shouldWrapRow`:**

  ```swift
  /// Determines if a row should use wrapping instead of truncation.
  /// Wrapping activates only when >50% of cells in the row would overflow their column width.
  /// - Parameters:
  ///   - cells: Array of cell content strings for the row
  ///   - columnWidths: Measured column widths
  ///   - font: The font used for measurement
  /// - Returns: true if the row should wrap, false for truncation
  private func shouldWrapRow(cells: [String], columnWidths: [CGFloat], font: NSFont) -> Bool {
      guard cells.count > 1 else { return false }  // Single-column rows don't need wrapping logic

      var overflowCount = 0
      for (index, content) in cells.enumerated() {
          guard index < columnWidths.count else { continue }
          let cellWidth = columnWidths[index]
          let padding = widthTier == .narrow ? 4.0 : 12.0  // 2pt or 6pt each side
          let availableTextWidth = cellWidth - padding

          let textWidth = (content as NSString).size(withAttributes: [.font: font]).width
          if textWidth > availableTextWidth {
              overflowCount += 1
          }
      }

      // Wrap only if >50% of cells overflow
      return Double(overflowCount) / Double(cells.count) > 0.5
  }
  ```

  **Add a helper to detect unbreakable strings:**

  ```swift
  /// Checks if a string is likely an unbreakable token (URL, file path, long identifier).
  /// These should always truncate, never mid-break.
  private func isUnbreakableString(_ content: String) -> Bool {
      // URLs, file paths, or strings with no spaces that are long
      let trimmed = content.trimmingCharacters(in: .whitespaces)
      if trimmed.contains("://") || trimmed.hasPrefix("/") || trimmed.hasPrefix("~") {
          return true
      }
      // Long strings with no spaces (identifiers, hashes, etc.)
      if trimmed.count > 20 && !trimmed.contains(" ") {
          return true
      }
      return false
  }
  ```

  **Update the `render(_ table:)` method:**

  Before rendering each body row, call `shouldWrapRow` to determine the row's wrapping mode. Pass this as a parameter to `renderCell`:

  1. For the header row: always use truncation (headers should stay on one line).

  2. For each body row:
     ```swift
     let rowFont = NSFont.systemFont(ofSize: bodyFontSize)
     let wrap = shouldWrapRow(cells: rowCells, columnWidths: columnWidths, font: rowFont)
     ```
     Then pass `shouldWrap: wrap` to each renderCell call for that row.

  **Update `renderCell` signature** to accept `shouldWrap: Bool`:

  ```swift
  private func renderCell(
      table: NSTextTable,
      row: Int,
      column: Int,
      content: String,
      isHeader: Bool,
      alignment: Table.ColumnAlignment?,
      columnWidths: [CGFloat],
      shouldWrap: Bool = false  // New parameter, default false for headers
  ) -> NSAttributedString
  ```

  **Update paragraph style logic in `renderCell`:**

  Replace the current unconditional `.byTruncatingTail` with:

  ```swift
  // Determine line break mode based on wrap decision and content type
  if isHeader || !shouldWrap || isUnbreakableString(content) {
      // Headers always truncate; unbreakable strings always truncate
      paragraphStyle.lineBreakMode = .byTruncatingTail
  } else {
      // Wrapping mode: allow word wrap with line cap
      paragraphStyle.lineBreakMode = .byWordWrapping

      // Cap at 3 lines by setting maximumLineHeight constraint
      // Use paragraphStyle to limit visible lines
      let lineHeight = font.ascender - font.descender + font.leading
      let maxLines: CGFloat = 3.0
      // Note: NSParagraphStyle doesn't have a native maxLines property.
      // Instead, we'll handle this via NSTextTableBlock height constraint.
  }
  ```

  **Implement the 3-line cap** using NSTextTableBlock height:

  When wrapping is enabled, set a maximum content height on the block:
  ```swift
  if shouldWrap && !isHeader && !isUnbreakableString(content) {
      let lineHeight = ceil(font.ascender - font.descender + font.leading)
      let maxLines: CGFloat = 3.0
      let cellPaddingVertical = widthTier == .narrow ? 2.0 : 6.0
      let maxHeight = lineHeight * maxLines + cellPaddingVertical * 2
      block.setContentHeight(maxHeight, type: .absoluteValueType)
  }
  ```

  If `setContentHeight` on NSTextTableBlock doesn't properly cap visible lines (NSTextTable can be unpredictable), fall back to truncating content manually before rendering:

  **Fallback: manual content truncation to approximate 3 lines:**
  ```swift
  // If wrapping, estimate how many characters fit in 3 lines and truncate
  if shouldWrap && !isHeader && !isUnbreakableString(content) {
      let availableTextWidth = (columnWidths[safe: column] ?? 100) - (widthTier == .narrow ? 4.0 : 12.0)
      let avgCharWidth = ("M" as NSString).size(withAttributes: [.font: font]).width
      let charsPerLine = max(1, Int(availableTextWidth / avgCharWidth))
      let maxChars = charsPerLine * 3  // 3 lines worth
      if content.count > maxChars {
          displayText = String(content.prefix(maxChars)) + "\u{2026}"  // ellipsis
      }
  }
  ```

  Use whichever approach (block height or manual truncation) produces more reliable results. Test both if time permits, but prefer `setContentHeight` if it works correctly since it's cleaner. If neither works reliably, use manual content truncation as the safe fallback.

  **GFM alignment verification:**
  The existing alignment code in `renderCell` already maps `Table.ColumnAlignment` to `NSParagraphStyle.alignment` correctly. Verify it handles all three cases (.left, .center, .right) plus nil default (left). No changes needed — just verify it still works after the wrap/truncate changes.
  </action>
  <verify>
  Build succeeds: `cd /Users/razielpanic/Projects/md-spotlighter && make build`

  Verify key behaviors by reading the code:
  - `shouldWrapRow` method exists and checks >50% overflow threshold
  - `isUnbreakableString` detects URLs, paths, and long spaceless strings
  - Header cells always truncate
  - Body cells wrap only when shouldWrapRow returns true AND content is not unbreakable
  - 3-line cap is implemented (via block height or manual truncation)
  - GFM alignment (.left, .center, .right) still applied in paragraph style
  </verify>
  <done>
  TableRenderer implements smart wrap/truncate hybrid: rows default to truncation for tight scannable layout. When >50% of cells in a row overflow their column width, wrapping activates with a 3-line cap. Unbreakable strings (URLs, paths, long identifiers) always truncate. Headers always truncate. GFM column alignment markers are respected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add table spacing and build verification</name>
  <files>MDQuickLook/MDQuickLook Extension/TableRenderer.swift</files>
  <action>
  Add proper spacing between tables and surrounding content, and perform a final build verification.

  **Table spacing (Claude's discretion area):**

  Add spacing before and after table content in the `render` method. After building the complete table attributed string, append a trailing newline with paragraph spacing to separate the table from subsequent content:

  ```swift
  // At the end of render(), before returning result:
  // Add spacing after table for visual separation from following content
  let spacingStyle = NSMutableParagraphStyle()
  spacingStyle.paragraphSpacing = widthTier == .narrow ? 6 : 12
  spacingStyle.paragraphSpacingBefore = 0
  result.append(NSAttributedString(string: "\n", attributes: [
      .paragraphStyle: spacingStyle,
      .font: NSFont.systemFont(ofSize: 1)  // Tiny font for spacing-only line
  ]))
  ```

  This ensures tables don't visually collide with paragraphs, lists, or other tables that follow.

  **Dark mode border contrast tuning (Claude's discretion area):**

  The current `NSColor.separatorColor` for header borders already adapts to dark mode automatically. Verify this is correct by confirming:
  - Header cells use `NSColor.separatorColor` for `.maxY` border (already present)
  - No hardcoded colors anywhere in TableRenderer
  - All foreground colors use `NSColor.labelColor` or `NSColor.quaternaryLabelColor`

  No changes needed if semantic colors are already used throughout — just verify.

  **Final cleanup:**
  - Remove any unused properties or dead code from previous TableRenderer iterations
  - Ensure all os_log statements use appropriate log levels (.info for key events, .debug for details)
  - Add an os_log in shouldWrapRow to log the decision: `os_log("TableRenderer: Row %d wrap decision: %{public}s (%d/%d cells overflow)", ...)`
  </action>
  <verify>
  Full build verification: `cd /Users/razielpanic/Projects/md-spotlighter && make build`

  Check that build produces zero errors and zero warnings related to TableRenderer.

  Read through final TableRenderer.swift to verify:
  - No hardcoded pixel widths remain (all use tier-aware values or availableWidth)
  - All colors are semantic NSColor values
  - Table spacing exists after rendered tables
  - os_log statements present for key decision points
  </verify>
  <done>
  TableRenderer has proper spacing between tables and surrounding content. All colors use semantic NSColor values for automatic dark mode support. Code is clean with no dead code. Build passes with zero errors.
  </done>
</task>

</tasks>

<verification>
- `make build` succeeds with zero errors
- Smart wrap/truncate: rows truncate by default, wrap only when >50% cells overflow
- 3-line cap on wrapped cells prevents excessively tall rows
- Unbreakable strings (URLs, paths) always truncate
- Headers always truncate
- GFM alignment markers (.left, .center, .right) respected
- Table spacing separates tables from surrounding content
- All colors are semantic (no hardcoded hex/RGB values)
- Builds and compiles cleanly on macOS 26
</verification>

<success_criteria>
- Smart truncation by default with ellipsis for scannable rows
- Row-level wrapping decision based on >50% overflow threshold
- 3-line maximum when wrapping is active
- Unbreakable string protection (URLs, paths always truncate)
- Proper table spacing from surrounding content
- All semantic colors for dark mode compatibility
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-table-rendering/13-02-SUMMARY.md`
</output>
